## 三色抽象

### 三色抽象

为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类：

- 白色对象 潜在的垃圾，其内存可能会被垃圾收集器回收；
- 黑色对象 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
- 灰色对象 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

### Tri-color invariant / 三色抽象原则

- `强三色不变原则`：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象
- `弱三色不变原则`：黑色对象指向的白色对象必须存在于一条包含灰色对象的且可到此白色对象的可达路径中

- `根本原则`：无论是强还是弱三色不变原则其共同的最终目的都是为了保证内存中一定不存在白色对象无法被 GC 的路径遍历算法遍历到，需要保证这一点的前提只有一个 --- 那就是保证所有白色对象的引用链路上游中至少存在一个灰色对象，所谓的强/弱原则只是满足这个前提的两种方式。

## Barrier / 屏障技术

### Dijkstra Write Barrier / Dijkstra 插入写屏障

```go
writePointer(slot, ptr):
    shade(ptr)
    *slot = ptr
```

`Dijkstra` 写屏障在指定位置 `slot` 写入指针 `ptr` 之前会通过 `shade(ptr)` 将 `ptr` 指向的非白色对象强制转换为灰色对象以确保**强三色不变原则**不被破坏。

> 强三色不变原则: 不存在任何黑色对象包含指向白色对象的指针

其最大的缺陷便是在处理 `Stack` 上的指针写入时不得不考虑采取 1. 采用写屏障在将指针写入到栈上时进行染色（意味着巨大的性能消耗） 2. STW 并在此期间重新扫描所有栈 两种方案中的一种。在 `1.7` 之前 go 选择的便是第二种方式解决这个问题。

> 因为 `Stack` 上的指针指向的对象是 `GC` 开始扫描的根对象，如果我们在向一个已经被 `GC` 扫描过的 `Stack` 上保存指针的时候，我们无法确定被保存的指针是否指向的是一个白色对象，也就是一个白色对象成为了根对象，也就违反了在三色原则中我们提到的根本原则。

### Yuasa Write Barrier / Yuasa 删除写屏障

```go
writePointer(slot, ptr):
    shade(*slot)
    *slot = ptr
```

`Yuasa` 写屏障不同于 `Dijkstra` 的地方就在于它染色的目标不是需要写入的值 `ptr` ，而是需要写入位置原来指向的对象 `*slot`，随后将 `ptr` 赋值到 `slot` 位置。也就是其确保了**弱三色不变原则**不被破坏，因为在写入 `ptr` 前原对象 `*slot` 会被 shade 染为灰色，此时原对象已经其引用的其他对象都能保证被 `GC` 扫描到以此满足了 `根本原则`。

其最大的缺陷便是其 `shade(*slot)` 的拦截写操作会导致扫描中对象可能出现从 黑色 -> 灰色得转化从而导致此对象被 `GC` 二次扫描而形成波面的后退，降低 `GC` 性能。

> `GC` 扫描标记可回收对象的过程就像一个拂过对象之海的波峰一样，未标记与已标记的分界便是一个高维对象的分界面，我们称其为**波面**。

### Hybrid Write Barrier / 混合写屏障

```go
writePointer(slot, ptr):
    shade(*slot)
    if current stack is grey:
        shade(ptr)
    *slot = ptr
```

`Hybrid Write Barrier`意为混合写屏障，实际其包含了 `Yuasa` 和 `Dijkstra` 两种写屏障，令人意外的是混合写屏障实际上并不满足**强三色不变原则**，

## 链接

[1] [Eliminate STW stack re-scanning](https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md)
